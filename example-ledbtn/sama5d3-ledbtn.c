#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <event2/event.h>
#include <linux/input.h>

#include <json.h>

#include "pubnub.h"
#include "pubnub-libevent.h"


/* In this PubNub client, we subscribe to the "sama5d3" channel (by default
 * using demo/demo pub/sub keys).
 *
 * Whenever a user button is pressed, we will fire up a message saying
 * {"btn": 1}; when it is released, we send {"btn": 0}.
 *
 * When we receive e.g. the message {"leds": {"3": 1, "2": 0}}, we turn on
 * the red LED (#3) and turn off the blue LED (#2). */

const static char chname[] = "sama5d3";


static void
check_led(struct json_object *leds, const char *lednum)
{
	/* Load value for the LED, if it was specified. */
	json_object *value = json_object_object_get(leds, lednum);
	if (!value || !json_object_is_type(value, json_type_int))
		return;
	int val = json_object_get_int(value);
	if (val < 0 || val > 255)
		return; // out of range

	/* Set the LED value in hardware. */
	printf("led %s set to %d\n", lednum, val);
	char filename[64];
	snprintf(filename, sizeof(filename), "/sys/devices/leds/leds/d%s/brightness", lednum);
	FILE *f = fopen(filename, "w");
	if (!f) {
		perror(filename);
		exit(EXIT_FAILURE);
	}
	fprintf(f, "%d", val);
	fclose(f);
}

static void
process_message(struct pubnub *p, struct json_object *msg)
{
	json_object *leds = json_object_object_get(msg, "leds");
	if (!leds || !json_object_is_type(leds, json_type_object))
		return;
	check_led(leds, "2");
	check_led(leds, "3");
}

static void
subscribe_received(struct pubnub *p, enum pubnub_res result, char **channels, struct json_object *msg, void *ctx_data, void *call_data)
{
	/* ctx_data is (struct pubnub_libevent *) */
	/* call_data is NULL as that's what we passed to pubnub_subscribe_multi() */

	if (result == PNR_CANCELLED) {
		free(channels);
		return;
	}

	if (result != PNR_OK)
		/* This must be something fatal, we retry on recoverable
		 * errors. */
		exit(EXIT_FAILURE);

	if (json_object_array_length(msg) == 0) {
		printf("pubnub subscribe ok, no news\n");
	} else {
		for (int i = 0; i < json_object_array_length(msg); i++) {
			json_object *msg1 = json_object_array_get_idx(msg, i);
			printf("pubnub subscribe [%s]: %s\n", channels[i], json_object_get_string(msg1));
			process_message(p, msg1);
			free(channels[i]);
		}
	}
	free(channels);

	/* Loop. */
	pubnub_subscribe(p, NULL, -1, subscribe_received, NULL);
}


/* The "button pressed" callback chain. */

static struct event *inputev;

static void
publish_done(struct pubnub *p, enum pubnub_res result, struct json_object *msg, void *ctx_data, void *call_data)
{
	/* ctx_data is (struct pubnub_libevent *) */
	/* call_data is NULL as that's what we passed to pubnub_publish() */

	/* Start listening for input events again. */
	event_add(inputev, NULL);

	if (result != PNR_OK)
		/* An unrecoverable error, we just terminate with an
		 * error code. Since pubnub_error_policy()'s print is
		 * true by default, an explanation has already been
		 * written to stderr and we tried to retry as well. */
		exit(EXIT_FAILURE);

	printf("pubnub publish ok\n");
}

static void
read_input(int fd, short kind, void *userp)
{
	struct pubnub *p = userp;

	struct input_event inpev;
	int n = read(fd, &inpev, sizeof(inpev));
	if (n == -1) {
		perror("read from /dev/input");
		exit(EXIT_FAILURE);
	}
	if (n < sizeof(inpev)) {
		fprintf(stderr, "short read of %d < %zd bytes\n", n, sizeof(inpev));
		exit(EXIT_FAILURE);
	}

	/* Install input-utils and run:
	 *   input-events /dev/input/event0
	 * to easily watch the input events generated by the button. */
	/* 0x104 (BTN_4) is the code generated by the userbutton GPIO. */
	if (inpev.type == EV_SYN)
		return; // ignore without warning
	if (inpev.type != EV_KEY || inpev.code != 0x104) {
		fprintf(stderr, "Ignoring unknown input event %x, %x, %u\n",
			inpev.type, inpev.code, inpev.value);
		return;
	}
	int value = inpev.value;

	/* When publish is already in progress, we cannot issue a second
	 * publish in parallel.  Therefore, whenever we issue a publish,
	 * we stop monitoring the inputev file until the publish is finished.
	 * The events received meantime will simply queue up in the file
	 * descriptor (up to at least 8 physical button presses; see
	 * EVDEV_BUF_PACKETS in kernel drivers/input/evdev.c), so we typically
	 * should not lose any events. */
	/* But in general, PubNub is not suitable for publishing a *flood*
	 * of messages many times per second (it will actually tend to rate
	 * limit you) so if a user is prone to press a button very frequently
	 * you should batch the events up in a single message or throw away
	 * some of the presses. */
	event_del(inputev);

	/* Generate a PubNub notification. */
	json_object *msg = json_object_new_object();
	json_object_object_add(msg, "btn", json_object_new_int(value));

	printf("pubnub publishing: %s\n", json_object_get_string(msg));
	pubnub_publish(p, chname, msg, -1, publish_done, NULL);
	json_object_put(msg);
}


int
main(void)
{
	/* Set up the libevent library. */
	struct event_base *evbase = event_base_new();

	/* Set up the PubNub library, with a single subscription context
	 * for receiving messages and a publish context for sending messges,
	 * using the libevent backend for event handling. */
	struct pubnub *psub = pubnub_init("demo", "demo", &pubnub_libevent_callbacks, pubnub_libevent_init(evbase));
	struct pubnub *ppub = pubnub_init("demo", "demo", &pubnub_libevent_callbacks, pubnub_libevent_init(evbase));

	/* Subscribe to our channel. */
	printf("Subscribing to channel '%s'\n", chname);
	pubnub_subscribe(psub, chname, -1, subscribe_received, NULL);

	/* Start listening for input events. */
	int inputfd = open("/dev/input/event0", O_RDONLY);
	if (inputfd < 0) {
		perror("/dev/input/event0");
		exit(EXIT_FAILURE);
	}
	inputev = event_new(evbase, inputfd, EV_READ | EV_PERSIST, read_input, ppub);
	event_add(inputev, NULL);

	/* Start the event loop. */
	event_base_dispatch(evbase);

	/* We should never reach here. */
	pubnub_done(ppub);
	pubnub_done(psub);
	return EXIT_SUCCESS;
}
